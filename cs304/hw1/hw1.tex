\documentclass[11pt]{article} % 

\usepackage{listings}
\usepackage{amsmath}
\usepackage{enumitem}

\setlength{\oddsidemargin}{-0.15in}
\setlength{\topmargin}{-0.5in}
\setlength{\textwidth}{6.5in}
\setlength{\textheight}{9in}
\setlength\parindent{0pt}

\newcommand{\hr}{\noindent\rule{14cm}{0.4pt}}

\begin{document} 
%\maketitle

\noindent Kelvin Abrokwa-Johnson \\
14 March 2016 \\
CS 304

\begin{center} Homework 1 \end{center}


{\bf 1.}

\begin{enumerate}[label=\alph*)]

\item
The code fails to comply with the C standard because it attempts to shift beyond the word size. In many systems the shift amount will be applied $mod$ the word size so an attempt to shift by $32$ with result in a $32 \mod 32 = 0$ shift.

\item
\hr
\begin{lstlisting}[language=C]
int int_size_is_32() {
	int set_msb = 1 << 31;
	int beyond_msb = 2 << 31;
	return set_msb && !beyond_msb;
}
\end{lstlisting}
\hr


\item
\hr
\begin{lstlisting}[language=C]
int int_size_is_32() {
	int i = 1 << 15;
	i = i << 15; // 0 if less than 32 bit
	int j = 4  << 15;
	j = j << 15;
	return i && !j;
}
\end{lstlisting}
\hr
\end{enumerate}




\vspace{0.5in}
{\bf 2.}

\begin{enumerate}[label=\alph*)]


\item 
Doesn't perform sign extension.

\item
\hr
\begin{lstlisting}[language=C]
int xbyte(packed_t word, int bytenum) {
	word = word >> (bytenum << 3);
	word = word << 24;
	word = word >> 24;
	return word;
}
\end{lstlisting}
\hr
\end{enumerate}

\vspace{0.5in}
{\bf 3.}
\begin{enumerate}[label=\alph*)]
\item
The conditional test always succeeds because $sizeof()$ returns type $size\_t$ which is an unsigned data type. So the subtraction will result in an unsigned number which will always be less than or equal to $0$.
\item
\hr
\begin{lstlisting}[language=C]
void copy_int(int val, void *buf, int maxbytes) {
	if (maxbytes >= (int)sizeof(val))
		memcpy(buf, (void *) &val, sizeof(val));
}
\end{lstlisting}
\hr


\end{enumerate}


{\bf 4.}

\begin{enumerate}[label=\alph*)]
\item $(x << 4) + x$
\item $x - (x << 3)$
\item $(x << 6) - (x << 2)$
\item $(x << 4) - (x << 7)$
\end{enumerate}


\vspace{0.5in}
{\bf 5.}

\begin{enumerate}[label=\alph*)]

\item
$ \sim 0 << k$

\item
\begin{lstlisting}[language=C]
int create_val(int i, int j) {
	r = 0;
	for (int i = j + 1; i =< j + k; i++) {
		r += 1 << i;
	}
	return i;
}
\end{lstlisting}
\end{enumerate}

\pagebreak
{\bf 6.}
\begin{enumerate}[label=\alph*)]
\item
$(x < y) == (-x > -y)$: \\
When $x = TMin_w$ the first condition will evaluate to true and the second will be false. So this will return $0$.

\item
$((x+y)<<4) + y-x == 17*y+15*x$: \\
We know that a bit shift is equivalent to multiplication by powers of $2$ and since multiplication is distributive $((x+y)<<4) == (x << 4) + (y << 4)$. So we can replace the left side of the equality with $(y << 4) + y + (x << 4) - x$.  On the right side we can rewrite the multiplications as sums of powers of $2$. So $17*y$ becomes $)y << 4) + y$ and $15*x$ becomes $x << 4 - x$. We now see that the left side if equivalent to the right side.

\item
$\sim x+ \sim y+1 == \sim (x+y)$: \\
When $x = y = \sim 0$ (all bits set to $1$), the left side of the expression $\sim x+ \sim y+1$ evaluates to $1$ but the left side of the equation $\sim (x + y)$ evaluates to $\sim 0$ (all bits set to $1$).

\item
$(ux-uy) == -(unsigned)(y-x)$:


\item
$((x >> 2) << 2) <= x$: \\
In any case (where the most significant bit of $x$ is $0$ or $1$) when we shift left and then right we will fill in $0$'s on the left side and any added bits will overflow on the right side. So this expression is always true.

\end{enumerate}

\vspace{0.5in}
{\bf 7.}

\begin{center}
	\begin{tabular}{ | l | l | l | l | l | l |}
		\hline
		description & Hex & M & E & V & D \cr \hline
		$-0$ & & & & $0$ & $-0.0$ \cr \hline
		smallest value $>$ $2$ & & & & & \cr \hline
		$512$ & & &  & $512$ & $512.0$ \cr \hline
		largest denormalized & & & & & \cr \hline
		$-\infty$ & & - & - & $-\infty$ & $-\infty$ \cr \hline
		number with hex $3BB0$ & & & & & \cr \hline
	\end{tabular}
\end{center}

\vspace{0.5in}
{\bf 8.}
\begin{enumerate}[label=\alph*)]
\item (float) x == (float)
\item dx - dy == (double) (x-y)
\item (dx + dy) + dz == dx + (dy + dz)
\item (dx * dy) * dz == dx * (dy * dz)
\item dx / dx == dz / dz
\end{enumerate}


\vspace{0.5in}
{\bf 9.}
\begin{lstlisting}[language=C]
float fpwr2(int x)
{
	/* Result exponent and fraction */
	unsigned exp, frac;
	unsigned u;
	if (x < _________){
		/* Too small. Return 0.0 */
		exp = _________;
		frac = _________;
	} else if (x < _________){
		/* Denormalized result */
		exp = _________;
		frac = _________;
	} else if (x < _________){
		/* Normalized result. */
		exp = _________;
		frac = _________;
	} else {
		/* Too big. Return +oo */
		exp = _________;
		frac = _________;
	}
	/* Pack exp and frac into 32 bits */
	u = exp << 23 | frac;
	/* Return as float */
	return u2f(u);
}
\end{lstlisting}

\vspace{0.5in}
{\bf 10.}

\end{document}